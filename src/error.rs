use std::{
    ffi::OsString,
    fmt::{
        Display,
        Formatter,
        Result as FmtResult,
    },
    num::{
        ParseFloatError,
        ParseIntError,
    },
};

use crate::consts::*;

use self::wrapped_error::IoError;

mod wrapped_error;
/// All errors generated by this program are variants of this [Error] type.  See the [Error] type's variants for more
/// details.
#[derive(Debug, PartialEq)]
pub enum Error {
    /// Returned when a provided argument is not convertible to `UTF-8` (required in order to be a [String] in Rust).
    /// The argument is provided as this variant's payload for informational purposes.
    ArgNotConvertibleToUtf8(OsString),
    /// Returned when a provided argument is not convertible to [NonZeroUsize].  The failing argument is
    /// provided as this variant's payload for informational purposes.
    ArgNotConvertibleToNonZeroUsize(usize),
    /// Returned when a provided value is not convertible to a probability, which ranges from 0.0 to 1.0, inclusive.
    /// The invalid value is provided as this variant's payload for informational purposes.
    InvalidProbabilityRange(f64),
    /// IoError
    IoError(IoError),
    /// Returned when a provided argument is not convertible to an integer.  The original error is provided as this
    /// variant's payload for informational purposes.
    ParseInt(ParseIntError),
    /// Returned when a provided argument is not convertible to an floating point value.  The original error is provided
    /// as this variant's payload for informational purposes.
    ParseFloat(ParseFloatError),
}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{}", match self {
            Error::ArgNotConvertibleToUtf8(os_string) => format!("{}: {:?}",
                                                                 msg::ERR_ARG_NOT_CONVERTIBLE_TO_UTF_8,
                                                                 os_string),
            Error::ArgNotConvertibleToNonZeroUsize(val) => format!("{}: {:?}",
                                                                   msg::ERR_ARG_NOT_CONVERTIBLE_TO_NON_ZERO_USIZE,
                                                                   val),
            Error::InvalidProbabilityRange(val) => format!("{}: {}", msg::ERR_INVALID_PROBABILITY_RANGE, val),
            Error::IoError(err) => format!("{:?}", err),
            Error::ParseInt(err) => format!("{}: {}", msg::ERR_PARSE_INT, err),
            Error::ParseFloat(err) => format!("{}: {}", msg::ERR_PARSE_FLOAT, err),
        })
    }
}

impl From<IoError> for Error {
    fn from(err: IoError) -> Self {
        Error::IoError(err)
    }
}

impl From<OsString> for Error {
    fn from(err: OsString) -> Self {
        Error::ArgNotConvertibleToUtf8(err)
    }
}

impl From<ParseFloatError> for Error {
    fn from(err: ParseFloatError) -> Self {
        Error::ParseFloat(err)
    }
}

impl From<ParseIntError> for Error {
    fn from(err: ParseIntError) -> Self {
        Error::ParseInt(err)
    }
}
